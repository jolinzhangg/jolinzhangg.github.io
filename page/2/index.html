<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="含英咀华，凤凰于飞">
<meta property="og:type" content="website">
<meta property="og:title" content="凤凰花开芙蓉畔">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="凤凰花开芙蓉畔">
<meta property="og:description" content="含英咀华，凤凰于飞">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="凤凰花开芙蓉畔">
<meta name="twitter:description" content="含英咀华，凤凰于飞">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 凤凰花开芙蓉畔 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">凤凰花开芙蓉畔</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/juc/semaphore/" itemprop="url">
                  Semaphore
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-15T16:58:17+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/juc/" itemprop="url" rel="index">
                    <span itemprop="name">juc</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/15/juc/semaphore/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/juc/semaphore/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>建立一个包含n个许可的信号量(内部的计数为n)，当一个线程从信号量中请求一个许可(调用acquire())，如果信号量中有许可的话(n大于0)，那么线程成功获取许可，信号量内部许可数量减1(n减1)；如果信号量中没有许可(n等于0)，那么当前线程阻塞。</li>
<li>当一个线程归还许可(调用release()，内部计数加1)，其他在acquire()方法处等待的线程便有可能被唤醒来竞争许可。</li>
<li>公平模式下，如果有线程在acquire()处等待，新来的请求线程会排在这些等待线程后面；非公平模式下，新来的请求线程可能会插队，比在acquire()处等待的线程提前申请到许可。</li>
</ol>
<p>代码分析</p>
<pre><code>/*
 * 基于计数信号量，可用来管理一组许可
 */
public class Semaphore implements java.io.Serializable {
    private static final long serialVersionUID = -3222578661600680210L;
    /** All mechanics via AbstractQueuedSynchronizer subclass */
    private final Sync sync;

    /**
     * 通过AQS的state表示许可的数量，包含公平和非公平的实现
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1192457210091910933L;

        Sync(int permits) {
            setState(permits);
        }

        final int getPermits() {
            return getState();
        }
        // 共享模式非公平的请求
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                // 获取当前许可数量
                int available = getState();
                // 计算申请后剩余数量
                int remaining = available - acquires;
                /*
                 * 如果申请后剩余&gt;=0，则通过CAS修改，修改成功后返回剩余数量；
                 * 如果申请后剩余&lt;0，则直接返回数量
                 */
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
        /*
         * 释放所，CAS，有int越界判断
         */
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) // overflow
                    throw new Error(&quot;Maximum permit count exceeded&quot;);
                if (compareAndSetState(current, next))
                    return true;
            }
        }
        /*
         * 相当于release的逆操作
         */
        final void reducePermits(int reductions) {
            for (;;) {
                int current = getState();
                int next = current - reductions;
                if (next &gt; current) // underflow
                    throw new Error(&quot;Permit count underflow&quot;);
                if (compareAndSetState(current, next))
                    return;
            }
        }

        /*
         * 将count置为0并返回
         */
        final int drainPermits() {
            for (;;) {
                int current = getState();
                if (current == 0 || compareAndSetState(current, 0))
                    return current;
            }
        }
    }

    /**
     * 非公平
     */
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = -2694183684443567898L;

        NonfairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }

    /**
     * 公平
     */
    static final class FairSync extends Sync {
        private static final long serialVersionUID = 2014338818796000944L;

        FairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            for (;;) {
                // 公平版的请求，需要先检查同步队列里有没有比当前线程更早的线程在等待。  
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }

    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }

    public Semaphore(int permits, boolean fair) {
        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
    }

    /**
     * Acquires a permit from this semaphore, blocking until one is
     * available, or the thread is {@linkplain Thread#interrupt interrupted}.
     *
     * &lt;p&gt;Acquires a permit, if one is available and returns immediately,
     * reducing the number of available permits by one.
     *
     * &lt;p&gt;If no permit is available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until
     * one of two things happens:
     * &lt;ul&gt;
     * &lt;li&gt;Some other thread invokes the {@link #release} method for this
     * semaphore and the current thread is next to be assigned a permit; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If the current thread:
     * &lt;ul&gt;
     * &lt;li&gt;has its interrupted status set on entry to this method; or
     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
     * for a permit,
     * &lt;/ul&gt;
     * then {@link InterruptedException} is thrown and the current thread&apos;s
     * interrupted status is cleared.
     *
     * @throws InterruptedException if the current thread is interrupted
     */
    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    /**
     * Acquires a permit from this semaphore, blocking until one is
     * available.
     *
     * &lt;p&gt;Acquires a permit, if one is available and returns immediately,
     * reducing the number of available permits by one.
     *
     * &lt;p&gt;If no permit is available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until
     * some other thread invokes the {@link #release} method for this
     * semaphore and the current thread is next to be assigned a permit.
     *
     * &lt;p&gt;If the current thread is {@linkplain Thread#interrupt interrupted}
     * while waiting for a permit then it will continue to wait, but the
     * time at which the thread is assigned a permit may change compared to
     * the time it would have received the permit had no interruption
     * occurred.  When the thread does return from this method its interrupt
     * status will be set.
     */
    public void acquireUninterruptibly() {
        sync.acquireShared(1);
    }

    /**
     * Acquires a permit from this semaphore, only if one is available at the
     * time of invocation.
     *
     * &lt;p&gt;Acquires a permit, if one is available and returns immediately,
     * with the value {@code true},
     * reducing the number of available permits by one.
     *
     * &lt;p&gt;If no permit is available then this method will return
     * immediately with the value {@code false}.
     *
     * &lt;p&gt;Even when this semaphore has been set to use a
     * fair ordering policy, a call to {@code tryAcquire()} &lt;em&gt;will&lt;/em&gt;
     * immediately acquire a permit if one is available, whether or not
     * other threads are currently waiting.
     * This &amp;quot;barging&amp;quot; behavior can be useful in certain
     * circumstances, even though it breaks fairness. If you want to honor
     * the fairness setting, then use
     * {@link #tryAcquire(long, TimeUnit) tryAcquire(0, TimeUnit.SECONDS) }
     * which is almost equivalent (it also detects interruption).
     *
     * @return {@code true} if a permit was acquired and {@code false}
     *         otherwise
     */
    public boolean tryAcquire() {
        return sync.nonfairTryAcquireShared(1) &gt;= 0;
    }

    /**
     * Acquires a permit from this semaphore, if one becomes available
     * within the given waiting time and the current thread has not
     * been {@linkplain Thread#interrupt interrupted}.
     *
     * &lt;p&gt;Acquires a permit, if one is available and returns immediately,
     * with the value {@code true},
     * reducing the number of available permits by one.
     *
     * &lt;p&gt;If no permit is available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until
     * one of three things happens:
     * &lt;ul&gt;
     * &lt;li&gt;Some other thread invokes the {@link #release} method for this
     * semaphore and the current thread is next to be assigned a permit; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * &lt;li&gt;The specified waiting time elapses.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If a permit is acquired then the value {@code true} is returned.
     *
     * &lt;p&gt;If the current thread:
     * &lt;ul&gt;
     * &lt;li&gt;has its interrupted status set on entry to this method; or
     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
     * to acquire a permit,
     * &lt;/ul&gt;
     * then {@link InterruptedException} is thrown and the current thread&apos;s
     * interrupted status is cleared.
     *
     * &lt;p&gt;If the specified waiting time elapses then the value {@code false}
     * is returned.  If the time is less than or equal to zero, the method
     * will not wait at all.
     *
     * @param timeout the maximum time to wait for a permit
     * @param unit the time unit of the {@code timeout} argument
     * @return {@code true} if a permit was acquired and {@code false}
     *         if the waiting time elapsed before a permit was acquired
     * @throws InterruptedException if the current thread is interrupted
     */
    public boolean tryAcquire(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

    /**
     * Releases a permit, returning it to the semaphore.
     *
     * &lt;p&gt;Releases a permit, increasing the number of available permits by
     * one.  If any threads are trying to acquire a permit, then one is
     * selected and given the permit that was just released.  That thread
     * is (re)enabled for thread scheduling purposes.
     *
     * &lt;p&gt;There is no requirement that a thread that releases a permit must
     * have acquired that permit by calling {@link #acquire}.
     * Correct usage of a semaphore is established by programming convention
     * in the application.
     */
    public void release() {
        sync.releaseShared(1);
    }

    /**
     * Acquires the given number of permits from this semaphore,
     * blocking until all are available,
     * or the thread is {@linkplain Thread#interrupt interrupted}.
     */
    public void acquire(int permits) throws InterruptedException {
        if (permits &lt; 0) throw new IllegalArgumentException();
        sync.acquireSharedInterruptibly(permits);
    }

    public void acquireUninterruptibly(int permits) {
        if (permits &lt; 0) throw new IllegalArgumentException();
        sync.acquireShared(permits);
    }

    public boolean tryAcquire(int permits) {
        if (permits &lt; 0) throw new IllegalArgumentException();
        return sync.nonfairTryAcquireShared(permits) &gt;= 0;
    }

    public boolean tryAcquire(int permits, long timeout, TimeUnit unit)
        throws InterruptedException {
        if (permits &lt; 0) throw new IllegalArgumentException();
        return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));
    }

    public void release(int permits) {
        if (permits &lt; 0) throw new IllegalArgumentException();
        sync.releaseShared(permits);
    }

    public int availablePermits() {
        return sync.getPermits();
    }

    public int drainPermits() {
        return sync.drainPermits();
    }

    protected void reducePermits(int reduction) {
        if (reduction &lt; 0) throw new IllegalArgumentException();
        sync.reducePermits(reduction);
    }

    public boolean isFair() {
        return sync instanceof FairSync;
    }

    /**
     * Queries whether any threads are waiting to acquire. Note that
     * because cancellations may occur at any time, a {@code true}
     * return does not guarantee that any other thread will ever
     * acquire.  This method is designed primarily for use in
     * monitoring of the system state.
     *
     * @return {@code true} if there may be other threads waiting to
     *         acquire the lock
     */
    public final boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }

    public final int getQueueLength() {
        return sync.getQueueLength();
    }

    protected Collection&lt;Thread&gt; getQueuedThreads() {
        return sync.getQueuedThreads();
    }

    public String toString() {
        return super.toString() + &quot;[Permits = &quot; + sync.getPermits() + &quot;]&quot;;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/juc/countdownlatch/" itemprop="url">
                  CountDownLatch
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-15T15:34:09+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/juc/" itemprop="url" rel="index">
                    <span itemprop="name">juc</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/15/juc/countdownlatch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/15/juc/countdownlatch/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>package juc.test;
/**
 * 可以在闭锁上等待，每次执行countdown后，count-1，当count=0时，等待的线程被唤醒
 */
public class CountDownLatch {
    /**
     * 内部类，使用AQS同步，利用AQS的state做计数count
     */
    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;

        Sync(int count) {
            setState(count);
        }

        int getCount() {
            return getState();
        }

        /*
         * count=0请求成功；否则，请求失败，请求线程将被阻塞
         * 闭锁只有共享模式
         */
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        /*
         * 释放
         */
        protected boolean tryReleaseShared(int releases) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0) // 闭锁已经是0，无需释放
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc)) // CAS修改count=count-1
                    // 如果修改后为0表示闭锁已经打开，返回true；否则，说明还有等待的，闭锁处于关闭状态，返回false
                    return nextc == 0;
            }
        }
    }

    private final Sync sync;

    /*
     * 根据给定count值构造闭锁
     */
    public CountDownLatch(int count) {
        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);
        this.sync = new Sync(count);
    }

     /* 
      * 如果当前count为0，那么方法立即返回。 
      * 如果当前count不为0，那么当前线程会一直等待，直到count被(其他线程)减到0或者当前线程被中断。 
      */  
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1); // AQS中的实现
    }

    /*
     * 超时版await
     */
    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

    /*
     * 递减count，当减到0时，唤醒所有等待的线程去调度。如果当前count是0，则什么都不会发生
     */
    public void countDown() {
        sync.releaseShared(1);
    }

    public long getCount() {
        return sync.getCount();
    }

    public String toString() {
        return super.toString() + &quot;[Count = &quot; + sync.getCount() + &quot;]&quot;;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/juc/reentrantlock/" itemprop="url">
                  ReentrantLock
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T15:18:23+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/juc/" itemprop="url" rel="index">
                    <span itemprop="name">juc</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/14/juc/reentrantlock/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/juc/reentrantlock/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>和Synchronized一样，ReentrantLock也是可重入的，可作为内置锁的替代物。</p>
<p>与Synchronized相比较而言，ReentrantLock有以下优势：支持公平/非公平锁、支持可中断的锁、支持非阻塞的tryLock(可超时)、支持锁条件、可跨代码块使用(一个地方加锁，另一个地方解锁)，总之比Synchronized更加灵活。但也有缺点，比如锁需要显示解锁、无法充分享用JVM内部性能提升带来的好处等等。</p>
<pre><code>public interface Lock {
    /**
     * 获取锁，若无法获取到，则当前线程被阻塞。直到获取成功为止。
     */
    void lock();
    /**
     * 获取锁，若无法获取到，则当前线程被阻塞。直到发生以下两种情况：
     * 获取成功；或者
     * 其他线程中断当前线程 
     */
    void lockInterruptibly() throws InterruptedException;
    /**
     * 如果当前锁可用，获取成功返回true；否则返回false
     */
    boolean tryLock();
    /**
     * 与lockInterruptibly相似，还有第三种情况，即达到超时时间。
     * 如果当前锁可用，获取成功返回true；否则返回false
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    /**
     * 释放锁
     */
    void unlock();
    /**
     * 返回当前锁相关的条件。在条件等待之前，锁必须被当前线程占有，await方法会在等待前释放锁，在结束等待前重新获取锁
     */
    Condition newCondition();
}
</code></pre><p>基于AQS机制构建的同步类，内部都会使用相关类继承AQS。ReentrantLock也不例外。</p>
<pre><code>// 内部协调机制对象
private final Sync sync;
// 抽象类继承AQS，具有公平和非公平版本的子类。利用AQS的state来表示锁持有(重入)的次数。. 
abstract static class Sync extends AbstractQueuedSynchronizer 
</code></pre><p>非公平锁子类，新来的类之间尝试获取锁，无论等待队列中是否有线程阻塞等待。</p>
<pre><code>final static class NonfairSync extends Sync
</code></pre><p>公平锁子类，只有在递归(重入)或者同步队列中没有其他线程或者当前线程是等待队列中的第一个线程时才准许访问</p>
<pre><code>final static class FairSync extends Sync 
</code></pre><p>非公平版的锁-加锁操作</p>
<ol>
<li>当前线程首先会无条件的执行一个CAS操作来获取锁，如果CAS操作成功，获取锁成功。</li>
<li>如果第1步没成功，当前会检查锁是否被其他线程持有，也就是锁是否可用。</li>
<li>如果没有其他线程持有锁，会以CAS的方式尝试获取锁，如果CAS操作成功，获取锁成功。</li>
<li>如果有其他线程持有锁，会判断一下持有锁的线程是否为当前线程，如果是当前线程，重入次数+1，获取锁成功。</li>
<li>根据AQS的分析，上述2、3、4步会执行多次，如果最终获取锁失败，当前线程会被阻塞，等待其他线程执行解锁操作将其唤醒。</li>
</ol>
<p>公平版的锁-加锁操作</p>
<ol>
<li>当前线程首先会检查锁是否被其他线程持有，并且当前同步等待队列里有没有其他线程在等待。</li>
<li>如果没有其他线程持有锁，且同步等待队列里没有其他线程，会以CAS的方式尝试获取锁，如果CAS操作成功，获取锁成功。</li>
<li>如果有其他线程持有锁，会判断一下持有锁的线程是否为当前线程，如果是当前线程，重入次数+1，获取锁成功。nonfairTryAcquire方法</li>
<li>根据AQS的分析，上述1、2、3步会执行多次，如果最终获取锁失败，当前线程会被阻塞，等待其他线程执行解锁操作将其唤醒。</li>
</ol>
<p>非公平版和公平版锁的解锁操作一样</p>
<ol>
<li>当前线程首先将锁重入次数减1(AQS的state)，如果减1后结果为0，将当前同步器的线程信息置空，并唤醒同步等待队列中队头的等待线程。</li>
<li>如果第1步中，重入次数减1后结果不为0(说明当前线程还持有当前锁)，方法结束。</li>
</ol>
<p>ReentrantLock实现，整体就是sync的一个代理。</p>
<pre><code>public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = (fair)? new FairSync() : new NonfairSync();
}

public void lock() {
    sync.lock();
}

public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}

public boolean tryLock() {
    return sync.nonfairTryAcquire(1);
}

public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}

public void unlock() {
    sync.release(1);
}
public Condition newCondition() {
    return sync.newCondition();
}
</code></pre><p>所有try方法，相当于非阻塞的方式获取锁。</p>
<p>synchronized获得的内部锁存在一定的局限</p>
<ol>
<li><p>不能中断一个正在试图获得锁的线程 </p>
</li>
<li><p>试图获得锁时不能像trylock那样设定超时时间 </p>
</li>
<li><p>每个锁只有单一的条件，不像condition那样可以设置多个</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/redis/persistence/" itemprop="url">
                  持久化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T10:40:30+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/02/redis/persistence/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/02/redis/persistence/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>通过快照（snapshotting）完成，当出现以下几种情况时，进行快照：</p>
<ol>
<li>根据配置自动进行，在redis.conf中save部分</li>
<li>用户执行save（同步快照，会阻塞所有客户端请求）或bgsave（异步快照）</li>
<li>执行flushall（前提是必须定义自动快照条件，否则即使执行，也不会进行快照）</li>
<li>执行复制（replication），主从模式，在复制初始化时进行。</li>
</ol>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>默认快照文件存储在redis当前进程的工作目录中的dump.rdb文件中，通过redis-cli启动客户端时，文件在redis-cli所在的文件夹中。<br>使用fork函数赋值一份当前进程（父进程）的副本（子进程）。父进程继续接受并处理客户端的请求，而子进程开始将内存中的数据写入硬盘中的临时文件。写入所有数据后会用改临时文件替换旧的RDB文件，至此完成一次快照操作。</p>
<p>fork的时候，会使用写时赋值策略（copy-on-write），开始时共享内存，当父进程需要更改数据时，操作系统会将该数据复制一份保证子进程的数据不受影响，所以RDB文件存储的是执行fork时刻的内存数据。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>append only file，默认情况下不开启，可通过appendonly yes参数启用。每执行一条会更改redis数据的命令，redis就会将该命令写入磁盘中的aof文件。aof文件的位置和rdb文件的位置相同。</p>
<p>以纯文本形式记录了redis执行的写命令。每当达到一定条件时redis就会自动重写aof文件，去除文件中冗余的数据。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>由于操作系统缓存机制，数据并没有真正地写入硬盘，而是进入系统的硬盘缓存。默认情况下每30s执行一次同步操作，将缓存中的内容真正写入硬盘。</p>
<pre><code>appendfsync always    每次操作都同步
appendfsync everysec    没个若干秒同步；这是兼顾性能和安全的考虑。
appendfsync no    不同步，由操作系统决定，即30s
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/redis/getDeeper/" itemprop="url">
                  redis进阶
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-01T10:12:03+08:00" content="2016-06-01">
              2016-06-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/01/redis/getDeeper/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/01/redis/getDeeper/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>multi
...
exec

watch
</code></pre><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>在关系型数据库中一般需要一个额外的字段记录到期时间，然后定期检查，删除过期数据。在redis中可以使用expire命令设置一个键的过期时间，到时间后redis会自动删除它。</p>
<pre><code>set key value
expire key time 设置过期时间，返回1表示成功；0表示键不存在或设置失败
ttl key    返回键的剩余时间，单位是秒。当键不存在时，返回-2。-1表示永久键。
persist key 取消过期时间，将键改为永久键。使用set和getset赋值的同时也可以清楚过期时间。

对应的还有另外一组设置毫秒时间的
pexpire
pttl
</code></pre><p>过期时间实现访问频率限制</p>
<ol>
<li>利用过期时间，每分钟设置一个key，incr到指定数量时，拒绝。过期后重新计数。</li>
<li>用列表存储，每个新请求，判断列表是否到达最大长度，若未到达，直接加入；否则，与最早的时间比较，看时间间隔是否大于1分钟，若大于，将最早的时间删除，新时间插入；否则拒绝。</li>
</ol>
<p>过期时间实现缓存。限制redis占用的最大内存，不设置过期时间，而让redis通过一定的规则淘汰不需要的缓存键。修改maxmemory参数，设置maxmemory-policy。eg. allkeys-lru</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code>127.0.0.1:6379&gt; sadd posts 2 6 12 26
(integer) 4
127.0.0.1:6379&gt; smember posts
(error) ERR unknown command &apos;smember&apos;
127.0.0.1:6379&gt; smembers posts
1) &quot;2&quot;
2) &quot;6&quot;
3) &quot;12&quot;
4) &quot;26&quot;
127.0.0.1:6379&gt; hset post:2 time 1352619200
(integer) 1
127.0.0.1:6379&gt; hset post:6 time 1352619600
(integer) 1
127.0.0.1:6379&gt; hset post:12 time 1352610100
(integer) 1
127.0.0.1:6379&gt; hset post:26 time 1352612000
(integer) 1
127.0.0.1:6379&gt; sort posts
1) &quot;2&quot;
2) &quot;6&quot;
3) &quot;12&quot;
4) &quot;26&quot;
## 这里by的感觉很像是表连接
127.0.0.1:6379&gt; sort posts by post:*-&gt;time desc
1) &quot;6&quot;
2) &quot;2&quot;
3) &quot;26&quot;
4) &quot;12&quot;
</code></pre><p>通过sort命令的get参数，该参数不影响排序，作用是似的sort命令的返回结果不再是元素自身的值，而是get参数中指定的键值。</p>
<pre><code>127.0.0.1:6379&gt; sort posts by post:*-&gt;time desc get post:*-&gt;title
1) &quot;66666&quot;
2) &quot;windows 8&quot;
3) &quot;262626&quot;
4) &quot;121212&quot;
## 一个sort也可以带有多个get参数（但by只能有一个）
sort posts by post:*-&gt;time desc get post:*-&gt;title get post:*-&gt;time get #
1) &quot;66666&quot;
2) &quot;1352619600&quot;
3) &quot;windows 8&quot;
4) &quot;1352619200&quot;
5) &quot;262626&quot;
6) &quot;1352612000&quot;
7) &quot;121212&quot;
8) &quot;1352610100&quot;

get # 会返回元素本身。
</code></pre><p>store参数保存排序结果</p>
<pre><code>sort posts by post:*-&gt;time desc get post:*-&gt;title get post:*-&gt;time get # store sort.result  
(integer) 12   ## 保存的键类型是列表类型，返回值为结果个数
127.0.0.1:6379&gt; lrange sort.result 0 -1
 1) &quot;66666&quot;
 2) &quot;1352619600&quot;
 3) &quot;6&quot;
 4) &quot;windows 8&quot;
 5) &quot;1352619200&quot;
 6) &quot;2&quot;
 7) &quot;262626&quot;
 8) &quot;1352612000&quot;
 9) &quot;26&quot;
10) &quot;121212&quot;
11) &quot;1352610100&quot;
12) &quot;12&quot;
</code></pre><p>sort对性能的影响<br>O(n+mlog(m))，n为待排序列表中元素个数，m为排序结果返回的个数。</p>
<ol>
<li>尽量减少待排序键中元素的数量（减少n）</li>
<li>使用limit只获取需要的数据（减少m）</li>
<li>尽量使用store参数缓存</li>
</ol>
<h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><p>订阅功能，将用户邮箱存储在集合中，当新增文章后，就向集合中的邮箱地址发送通知邮件。</p>
<p>当页面需要进行如发送邮件、复杂数据运算等耗时较长的操作时会阻塞页面的渲染，为了避免用户等待太久，应该使用独立的线程来完成。</p>
<p>松耦合，生产者和消费者无需知道彼此的实现细节。易于扩展，消费者可以有多个，分布在不同机器中，轻松降低单台服务器的负载。</p>
<p>结合lpush和rpop，往列表左侧添加，右侧取出，模拟消息队列。同时redis提供brpop命令，当没有元素可以取出时，brpop命令将会阻塞，直到油新元素加入。</p>
<pre><code>brpop key timeout
其中time为超时时间，0表示不限制等待时间，即将一直等待下去。

brpop key [key ...] timeout 可以实现优先队列，当多个key对应的列表都有数据可以取出的时候，按从左到右的列表顺序
</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出，从简降低往返时延累计值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/redis/begin/" itemprop="url">
                  redis入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-31T15:04:03+08:00" content="2016-05-31">
              2016-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/31/redis/begin/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/31/redis/begin/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="几个基础命令"><a href="#几个基础命令" class="headerlink" title="几个基础命令"></a>几个基础命令</h2><pre><code>keys *
exists key
del key 由于del不支持通配符，所以可以结合管道和xargs，redis-cli keys &quot;user:*&quot; | xargs redis-cli del
type key 获取键值的数据类型
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre><code>set key value 赋值
get key 取值
incr key 递增数字

incrby key increment 增加指定整数
decr key
decrby key decrement
incrbyfloat key increment

append key value 向尾部追加
strlen key 获取字符串长度
mget key [key ...] 同时获取多个键值
mset key value [key value ...] 同时设置多个键值
</code></pre><p>最好使用“对象类型：对象ID：对象属性”来命名一个键，eg，user:1:friends</p>
<ul>
<li>文章访问量统计</li>
<li>生成自增ID（作用同关系型数据库的auto_increment）</li>
<li>存储文章数据</li>
</ul>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><pre><code>hset
hget
hmset
hmget
hgetall
hexists
hsetnx key field value 如果字段存在命令不执行任何操作
hincrby key field increment
hdel key field [field ...]
hkeys key 获取key对应的所有字段
hvals key 获取key对应的所有字段对应的值
hlen key 获取字段数量
</code></pre><ul>
<li>存储文章数据</li>
<li>存储文章缩略名</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>list可以向两端添加元素，或者获得列表的某一片段</p>
<pre><code>lpush key value [value ...]
rpush key value [value ...]
lpop key
rpop key
llen key
lrange key start stop
lrem key count value
lindex key index
lset key index value
ltrim key start end
linsert key before|after pivot value
rpoplpush source destination
</code></pre><ul>
<li>存储文章ID列表</li>
<li>存储品论列表</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><pre><code>sadd key number [number ...]
srem key number [number ...]
smembers key
sismember key member
sdiff key [key ...]
sinter key [key ...]
sunion key [key ...]
</code></pre><ul>
<li>存储文章标签</li>
<li>通过标签搜索文章</li>
</ul>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><pre><code>zadd key score member [member ...]
zscore key member
zrange key star stop [withscores] 按分数从小到大
zrevrange key start stop [withscores] 
zrangebyscore key min max [withscores] [limit offset count]
zincrby key increment member
zcard key 获取集合中元素的数量
zcount key min max
zrem key member [member ...]
zremrangebyrank key start stop 按排名范围删除元素
zremrangebyscore key min max 按照分数范围删除元素
zrank key member 获取元素排名
zrevrank key member 
</code></pre><ul>
<li>实现按点击量排序</li>
<li>改进按时间排序</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/30/linux/管理命令汇总/" itemprop="url">
                  linux管理维护命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-30T10:39:42+08:00" content="2016-05-30">
              2016-05-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/30/linux/管理命令汇总/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/30/linux/管理命令汇总/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p>nc localhost 20000 与 telnet localhost 20000相同</p>
<p>激活一个20000端口来监听连接</p>
<pre><code>nc -l localhost 20000 &amp;
netstat -tlunp | grep nc
nc localhost 20000
</code></pre><p>这里localhost为只开启本机测试，如果想通过其他机器连接，可以使用ip或域名。</p>
<p>linux命令中的&amp;，强制命令在后台执行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/30/linux/xinetd/" itemprop="url">
                  xinetd
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-30T10:20:16+08:00" content="2016-05-30">
              2016-05-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/30/linux/xinetd/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/30/linux/xinetd/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>抄一篇关于xinetd的，mark下。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/itech/archive/2010/12/27/1914846.html" target="_blank" rel="external">http://www.cnblogs.com/itech/archive/2010/12/27/1914846.html</a></p>
</blockquote>
<h2 id="守护进程分类"><a href="#守护进程分类" class="headerlink" title="守护进程分类"></a>守护进程分类</h2><p><strong>独立启动（stand_alone)</strong>:该类进程启动后就常驻内存，所以会一直占用系统资源。其最大的优点就是它会一直启动，当外界有要求时相应速度较快，像httpd等进程；</p>
<p><strong>超级守护进程</strong>：系统启动时由一个统一的守护进程xinet来负责管理一些进程，当相应请求到来时需要通过xinet的转接才可以唤醒被xinet管理的进程。这种进程的优点时最初只有xinet这一守护进程占有系统资源，其他的内部服务并不一直占有系统资源，只有数据包到来时才会被xinet管理员来唤醒。并且我们还可以通过xinet来对它所管理的进程设置一些访问权限，相当于多了一层管理机制。</p>
<h2 id="守护进程管理工具"><a href="#守护进程管理工具" class="headerlink" title="守护进程管理工具"></a>守护进程管理工具</h2><p>redhat－config－services、ntsysv、chkconfig</p>
<p>service iptables status    #查看相应服务的状态，用service需要服务在/etc/init.d/目录中存在</p>
<p>netstat -tulp    #会列出相应的服务及其监听的端口号等，若加n参数会列出端口号</p>
<p>chkconfig –list |grep 服务名 #会列出现在当前服务的各种状态，包括在不同运行级别下的启情况，分为上线两部分，上部分是独立启动的服务，你会看到xinetd也在，下面部分是有inet管理的超级守护进程，没有运行级别可分的。 </p>
<h2 id="xinetd"><a href="#xinetd" class="headerlink" title="xinetd"></a>xinetd</h2><p>从守护进程的概念可以看出，对于系统所要通过的每一种服务，都必须运行一个监听某个端口连接所发生的守护进程，这通常意味着资源浪费。为了解决这个问题，Linux引进了”网络守护进程服务程序”的概念。Red Hat Linux 9.0使用的网络守护进程是xinted（eXtended InterNET daemon）。xinetd能够同时监听多个指定的端口，在接受用户请求时，它能够根据用户请求的端口的不同，启动不同的网络服务进程来处理这些用户请求。可以把xinetd看做一个管理启动服务的管理服务器，它决定把一个客户请求交给哪个程序处理，然后启动相应的守护进程。xinetd无时不在运行并监听它所管理的所有端口上的服务。当某个要连接它管理的某项服务的请求到达时，xinetd就会为该服务启动合适的服务器。</p>
<p>xinetd和stand-alone工作模式相比，系统不想要每一个网络服务进程都监听其服务端口，运行单个xinetd就可以同时监听所有服务端口，这样就降低了系统开销，保护系统资源。但是对于访问量大、经常出现并发访问的情况，xinetd则要频繁启动相应的网络服务进程，反而会导致系统性能下降。查看系统为Linux服务提供哪种工作模式，可以在Linux命令行中使用pstree命令，就能看到两种不同模式启动的网络服务。一般来说系统中一些负载高的服务，Sendmail、Apache服务是单独启动的；而其他服务类型都可以使用xinetd超级服务器管理。</p>
<h3 id="什么是xinetd"><a href="#什么是xinetd" class="headerlink" title="什么是xinetd"></a>什么是xinetd</h3><p>xinetd即extended internet daemon，xinetd是新一代的网络守护进程服务程序，又叫超级Internet服务器。经常用来管理多种轻量级Internet服务。xinetd提供类似于inetd+tcp_wrapper的功能，但是更加强大和安全。</p>
<h3 id="xinetd的特色"><a href="#xinetd的特色" class="headerlink" title="xinetd的特色"></a>xinetd的特色</h3><h4 id="强大的存取控制功能"><a href="#强大的存取控制功能" class="headerlink" title="强大的存取控制功能"></a>强大的存取控制功能</h4><ul>
<li>内置对恶意用户和善意用户的差别待遇设定。</li>
<li>使用libwrap支持，其效能更甚于tcpd。</li>
<li>可以限制连接的等级，基于主机的连接数和基于服务的连接数。</li>
<li>设置特定的连接时间。</li>
<li>将某个服务设置到特定的主机以提供服务。</li>
</ul>
<h4 id="有效防止DoS攻击"><a href="#有效防止DoS攻击" class="headerlink" title="有效防止DoS攻击"></a>有效防止DoS攻击</h4><ul>
<li>可以限制连接的等级。</li>
<li>可以限制一个主机的最大连接数，从而防止某个主机独占某个服务。</li>
<li>可以限制日志文件的大小，防止磁盘空间被填满。</li>
</ul>
<h4 id="强大的日志功能"><a href="#强大的日志功能" class="headerlink" title="强大的日志功能"></a>强大的日志功能</h4><ul>
<li>可以为每一个服务就syslog设定日志等级。</li>
<li>如果不使用syslog，也可以为每个服务建立日志文件。</li>
<li>可以记录请求的起止时间以决定对方的访问时间。</li>
<li>可以记录试图非法访问的请求。</li>
</ul>
<h4 id="转向功能"><a href="#转向功能" class="headerlink" title="转向功能"></a>转向功能</h4><p>可以将客户端的请求转发到另一台主机去处理。</p>
<h4 id="支持IPv6"><a href="#支持IPv6" class="headerlink" title="支持IPv6"></a>支持IPv6</h4><p>xinetd自xinetd 2.1.8.8pre*起的版本就支持IPv6，可以通过在./configure脚本中使用with-inet6 capability选项来完成。注意，要使这个生效，核心和网络必须支持IPv6。当然IPv4仍然被支持。</p>
<h3 id="与客户端的交互功能"><a href="#与客户端的交互功能" class="headerlink" title="与客户端的交互功能"></a>与客户端的交互功能</h3><p>无论客户端请求是否成功，xinetd都会有提示告知连接状态。</p>
<h3 id="Xinetd的缺点"><a href="#Xinetd的缺点" class="headerlink" title="Xinetd的缺点"></a>Xinetd的缺点</h3><p>当前，它最大的缺点是对RPC支持的不稳定性，但是可以启动protmap，使它与xinetd共存来解决这个问题。</p>
<h3 id="使用xinetd启动守护进程"><a href="#使用xinetd启动守护进程" class="headerlink" title="使用xinetd启动守护进程"></a>使用xinetd启动守护进程</h3><p>原则上任何系统服务都可以使用xinetd，然而最适合的应该是那些常用的网络服务，同时，这个服务的请求数目和频繁程度不会太高。像DNS和Apache就不适合采用这种方式，而像FTP、Telnet、SSH等就适合使用xinetd模式，系统默认使用xinetd的服务可以分为如下几类。<br>① 标准Internet服务：telnet、ftp。<br>② 信息服务：finger、netstat、systat。<br>③ 邮件服务：imap、imaps、pop2、pop3、pops。<br>④ RPC服务：rquotad、rstatd、rusersd、sprayd、walld。<br>⑤ BSD服务：comsat、exec、login、ntalk、shell、talk。<br>⑥ 内部服务：chargen、daytime、echo、servers、services、time。<br>⑦ 安全服务：irc。<br>⑧ 其他服务：name、tftp、uucp。</p>
<h3 id="解读xinet的配置文件-etc-services-etc-xinetd-conf和-etc-xinetd-d"><a href="#解读xinet的配置文件-etc-services-etc-xinetd-conf和-etc-xinetd-d" class="headerlink" title="解读xinet的配置文件/etc/services, /etc/xinetd.conf和/etc/xinetd.d/*"></a>解读xinet的配置文件/etc/services, /etc/xinetd.conf和/etc/xinetd.d/*</h3><p>0）/etc/services</p>
<p>在/etc/services 中设置了xinetd下的service对应的端口，例如：</p>
<p>$  cat /etc/services | grep rsync<br>rsync           873/tcp                         # rsync<br>rsync           873/udp                         # rsync</p>
<p>1) /etc/xinetd.conf<br>xinetd的配置文件是/etc/xinetd.conf，但是它只包括几个默认值及/etc/xinetd.d目录中的配置文件。如果要启用或禁用某项xinetd服务，编辑位于/etc/xinetd.d目录中的配置文件。例如，disable属性被设为yes，表示该项服务已禁用；disable属性被设为no，表示该项服务已启用。/etc/xinetd.conf有许多选项，下面是RHEL 4.0的/etc/xinetd.conf。</p>
<pre><code>Simple configuration file for xinetd
Some defaults, and include /etc/xinetd.d/
defaults
{
    instances            = 60
        log_type             = SYSLOG authpriv
       log_on_success       = HOST PID
    log_on_failure       = HOST
    cps                  = 25 30
}
includedir /etc/xinetd.d
</code></pre><ul>
<li>instances = 60：表示最大连接进程数为60个。</li>
<li>log_type = SYSLOG authpriv：表示使用syslog进行服务登记。</li>
<li>log_on_success= HOST PID：表示设置成功后记录客户机的IP地址的进程ID。</li>
<li>log_on_failure = HOST：表示设置失败后记录客户机的IP地址。</li>
<li>cps = 25 30：表示每秒25个入站连接，如果超过限制，则等待30秒。主要用于对付拒绝服务攻击。</li>
<li>includedir /etc/xinetd.d：表示告诉xinetd要包含的文件或目录是/etc/xinetd.d。</li>
</ul>
<p>2) /etc/xinetd.d/*</p>
<p>下面以/etc/xinetd.d/中的一个文件（rsync）为例。<br>    service rsync<br>    {<br>        disable = yes<br>           socket_type      = stream<br>        wait              = no<br>        user              = root<br>        server           = /usr/bin/rsync<br>        log_on_failure += USERID<br>    }</p>
<p>下面说明每一行选项的含义。</p>
<ul>
<li>disable = yes：表示禁用这个服务。</li>
<li>socket_type = stream：表示服务的数据包类型为stream。</li>
<li>wait = no：表示不需等待，即服务将以多线程的方式运行。</li>
<li>user = root：表示执行此服务进程的用户是root。</li>
<li>server = /usr/bin/rsync：启动脚本的位置。</li>
<li>log_on_failure += USERID：表示设置失败时，UID添加到系统登记表。</li>
</ul>
<h3 id="配置xinetd"><a href="#配置xinetd" class="headerlink" title="配置xinetd"></a>配置xinetd</h3><p>1) 格式<br>/etc/xinetd.conf中的每一项具有下列形式：<br>    service service-name<br>    {<br>        ……<br>    }</p>
<p>其中service是必需的关键字，且属性表必须用大括号括起来。每一项都定义了由service-name定义的服务。</p>
<p>service-name是任意的，但通常是标准网络服务名，也可增加其他非标准的服务，只要它们能通过网络请求激活，包括localhost自身发出的网络请求。有很多可以使用的属性，稍后将描述必需的属性和属性的使用规则。</p>
<p>操作符可以是=、+=或-=。所有属性可以使用=，其作用是分配一个或多个值，某些属性可以使用+=或-=，其作用分别是将其值增加到某个现存的值表中，或将其值从现存值表中删除。</p>
<p>2) 配置文件<br>相关的配置文件如下：<br>/etc/xinetd.conf<br>/etc/xinetd.d/*                                      //该目录下的所有文件<br>/etc/hosts.allow<br>/etc/hosts.deny</p>
<p>3)/etc/xinetd.conf中的disabled与enabled<br>前者的参数是禁用的服务列表，后者的参数是启用的服务列表。他们的共同点是格式相同（属性名、服务名列表与服务中间用空格分开，例如disabled = in.tftpd in.rexecd），此外，它们都是作用于全局的。如果在disabled列表中被指定，那么无论包含在列表中的服务是否有配置文件和如何设置，都将被禁用；如果enabled列表被指定，那么只有列表中的服务才可启动，如果enabled没有被指定，那么disabled指定的服务之外的所有服务都可以启动。</p>
<p>4) 注意问题<br>① 在重新配置的时候，下列的属性不能被改变：socket_type、wait、protocol、type；<br>② 如果only_from和no_access属性没有被指定（无论在服务项中直接指定还是通过默认项指定），那么对该服务的访问IP将没有限制；<br>③ 地址校验是针对IP地址而不是针对域名地址。</p>
<p>6  xinetd防止拒绝服务攻击（Denial of Services）的原因<br>xinetd能有效地防止拒绝服务攻击（Denial of Services）的原因如下。</p>
<p>1) 限制同时运行的进程数<br>通过设置instances选项设定同时运行的并发进程数：<br>instances＝20<br>当服务器被请求连接的进程数达到20个时，xinetd将停止接受多出部分的连接请求。直到请求连接数低于设定值为止。</p>
<p>2) 限制一个IP地址的最大连接数<br>通过限制一个主机的最大连接数，从而防止某个主机独占某个服务。<br>per_source＝5<br>这里每个IP地址的连接数是5个。</p>
<p>3) 限制日志文件大小，防止磁盘空间被填满<br>许多攻击者知道大多数服务需要写入日志。入侵者可以构造大量的错误信息并发送出来，服务器记录这些错误，可能就造成日志文件非常庞大，甚至会塞满硬盘。同时会让管理员面对大量的日志，而不能发现入侵者真正的入侵途径。因此，限制日志文件大小是防范拒绝服务攻击的一个方法。<br>log_type FILE.1 /var/log/myservice.log 8388608 15728640<br>这里设置的日志文件FILE.1临界值为8MB，到达此值时，syslog文件会出现告警，到达15MB，系统会停止所有使用这个日志系统的服务。</p>
<p>4) 限制负载</p>
<p>xinetd还可以使用限制负载的方法防范拒绝服务攻击。用一个浮点数作为负载系数，当负载达到这个数目的时候，该服务将暂停处理后续的连接。<br>max_load = 2.8<br>上面的设定表示当一项系统负载达到2.8时，所有服务将暂时中止，直到系统负载下降到设定值以下。<br>说明  要使用这个选项，编译时应加入“–with-loadavg”，xinetd将处理max-load配置选项，从而在系统负载过重时关闭某些服务进程，来实现防范某些拒绝服务攻击。</p>
<p>5) 限制所有服务器数目（连接速率）<br>xinetd可以使用cps选项设定连接速率，下面的例子：<br>cps = 25 60<br>上面的设定表示服务器最多启动25个连接，如果达到这个数目将停止启动新服务60秒。在此期间不接受任何请求。</p>
<p>6) 限制对硬件资源的利用<br>通过rlimit_as和rlimit_cpu两个选项可以有效地限制一种服务对内存、中央处理器的资源占用：<br>rlimit_as = 8M<br>rlimit_cpu=20<br>上面的设定表示对服务器硬件资源占用的限制，最多可用内存为8MB，CPU每秒处理20个进程。</p>
<p>xinetd的一个重要功能是它能够控制从属服务可以利用的资源量，通过它的以上设置可以达到这个目的，有助于防止某个xinetd服务占用大量资源，从而导致“拒绝服务”情况的出现。 </p>
<p>六 Service命令</p>
<p>Linux的service命令就是查看和控制所有的独立启动的守护进程。 这个命令不是在所有的linux发行版本中都有。主要是在redhat系linux中。service此命令位于/sbin/service，用file命令查看此命令会发现它是一个脚本命令。分析脚本可知此命令的作用是去/etc/init.d目录下寻找相应的服务，进行开启和关闭等操作。例如service mysqld stop等价于/etc/init.d/mysqld stop。</p>
<p>七 xinetd本身也是一个独立的守护进程，在/etc/init.d/xinetd。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/27/generic/" itemprop="url">
                  泛型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-27T11:00:40+08:00" content="2016-05-27">
              2016-05-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/generic/" itemprop="url" rel="index">
                    <span itemprop="name">generic</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/27/generic/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/generic/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/ehcache/ehcache/" itemprop="url">
                  ehcache是什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T15:43:39+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/ehcache/" itemprop="url" rel="index">
                    <span itemprop="name">ehcache</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/ehcache/ehcache/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/ehcache/ehcache/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转自carlosfu大大的bigmemory系列文章:  <a href="http://carlosfu.iteye.com/blog/2237511" target="_blank" rel="external">http://carlosfu.iteye.com/blog/2237511</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/image/avatar.jpg"
               alt="Sunwind" />
          <p class="site-author-name" itemprop="name">Sunwind</p>
          <p class="site-description motion-element" itemprop="description">含英咀华，凤凰于飞</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sunwind</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jolinzhangg"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
